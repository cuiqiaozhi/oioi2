"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineCommand = exports.Command = void 0;
const argv_1 = require("./argv");
const util_1 = require("util");
class Command {
    constructor(name, declaration, description) {
        this.name = name;
        this.description = description;
        this.config = {};
        this._examples = [];
        this._aliases = [];
        this._actions = [];
        this._checkers = [];
        this._options = {};
        this.parent = null;
        this.children = [];
        this._namedOptions = {};
        this._symbolicOptions = {};
        if (!name)
            throw new Error('expect a command name');
        const decl = this._arguments = argv_1.Argv.parseDecl(declaration);
        this.declaration = decl.stripped;
        this._aliases.push(name);
    }
    option(name, desc, config = {}) {
        var _a;
        const param = name;
        const decl = desc.replace(/(?<=^|\s)[\w\x80-\uffff].*/, '');
        desc = desc.slice(decl.length);
        let syntax = decl.replace(/(?<=^|\s)(<[^<]+>|\[[^[]+\]).*/, '');
        const bracket = decl.slice(syntax.length);
        syntax = syntax.trim() || '--' + param;
        const names = [];
        const symbols = [];
        for (let param of syntax.trim().split(',')) {
            param = param.trimStart();
            const name = param.replace(/^-+/, '');
            if (!name || !param.startsWith('-')) {
                symbols.push(param);
            }
            else {
                names.push(name);
            }
        }
        if (!config.value && !names.includes(param)) {
            syntax += ', --' + param;
        }
        const declList = argv_1.Argv.parseDecl(bracket);
        if (declList.stripped)
            syntax += ' ' + declList.stripped;
        if (desc)
            syntax += '  ' + desc;
        const option = (_a = this._options)[name] || (_a[name] = {
            ...declList[0],
            ...config,
            name,
            values: {},
            description: syntax,
        });
        const fallbackType = typeof option.fallback;
        if ('value' in config) {
            names.forEach(name => option.values[name] = config.value);
        }
        else if (!bracket.trim()) {
            option.type = 'boolean';
        }
        else if (!option.type && (fallbackType === 'string' || fallbackType === 'number')) {
            option.type = fallbackType;
        }
        this._assignOption(option, names, this._namedOptions);
        this._assignOption(option, symbols, this._symbolicOptions);
        if (!this._namedOptions[param]) {
            this._namedOptions[param] = option;
        }
        return this;
    }
    _assignOption(option, names, optionMap) {
        for (const name of names) {
            if (name in optionMap) {
                throw new Error((0, util_1.format)('duplicate option name "%s" for command "%s"', name, this.name));
            }
            optionMap[name] = option;
        }
    }
    alias(...names) {
        for (const name of names) {
            this._aliases.push(name);
        }
        return this;
    }
    example(example) {
        this._examples.push(example);
        return this;
    }
    check(callback, prepend = false) {
        if (prepend) {
            this._checkers.unshift(callback);
        }
        else {
            this._checkers.push(callback);
        }
        return this;
    }
    action(callback, append = false) {
        if (append) {
            this._actions.push(callback);
        }
        else {
            this._actions.unshift(callback);
        }
        return this;
    }
    parse(argv, args = [], options = {}) {
        const source = this.name + ' ' + argv_1.Argv.stringify(argv);
        while (!argv.error && argv.tokens.length) {
            const token = argv.tokens[0];
            let { content, quoted } = token;
            const argDecl = this._arguments[args.length];
            if (content[0] !== '-' && argv_1.Argv.resolveConfig(argDecl?.type).greedy) {
                args.push(argv_1.Argv.parseValue(argv_1.Argv.stringify(argv), true, 'argument', argv, argDecl));
                break;
            }
            argv.tokens.shift();
            let option;
            let names;
            let param;
            if (!quoted && (option = this._symbolicOptions[content])) {
                names = [option.name];
            }
            else {
                if (content[0] !== '-' || quoted) {
                    args.push(argv_1.Argv.parseValue(content, quoted, 'argument', argv, argDecl || { type: 'string' }));
                    continue;
                }
                let i = 0;
                let name;
                for (; i < content.length; ++i) {
                    if (content.charCodeAt(i) !== 45)
                        break;
                }
                if (content.slice(i, i + 3) === 'no-' && !this._namedOptions[content.slice(i)]) {
                    name = content.slice(i + 3);
                    options[name] = false;
                    continue;
                }
                // find =
                let j = i + 1;
                for (; j < content.length; j++) {
                    if (content.charCodeAt(j) === 61)
                        break;
                }
                name = content.slice(i, j);
                names = i > 1 ? [name] : name;
                param = content.slice(++j);
                option = this._namedOptions[names[names.length - 1]];
            }
            quoted = false;
            if (!param) {
                const { type } = option || {};
                if (argv_1.Argv.resolveConfig(type).greedy) {
                    param = argv_1.Argv.stringify(argv);
                    quoted = true;
                    argv.tokens = [];
                }
                else if (type !== 'boolean' && argv.tokens.length && (type || argv.tokens[0]?.content !== '-')) {
                    const token = argv.tokens.shift();
                    param = token.content;
                    quoted = token.quoted;
                }
            }
            // handle each name
            for (let j = 0; j < names.length; j++) {
                const name = names[j];
                const optDecl = this._namedOptions[name];
                const key = optDecl ? optDecl.name : name;
                if (optDecl && name in optDecl.values) {
                    options[key] = optDecl.values[name];
                }
                else {
                    const source = j + 1 < names.length ? '' : param;
                    options[key] = argv_1.Argv.parseValue(source, quoted, 'option', argv, optDecl);
                }
                if (argv.error)
                    break;
            }
        }
        // assign default values
        for (const { name, fallback } of Object.values(this._options)) {
            if (fallback !== undefined && !(name in options)) {
                options[name] = fallback;
            }
        }
        delete argv.tokens;
        return { options, args, source, rest: argv.rest, error: argv.error || '' };
    }
    async execute(argv) {
        if (typeof argv === 'string')
            argv = argv_1.Argv.parse(argv);
        if (argv?.tokens.length) {
            const { content: name } = argv.tokens.shift();
            if (!this._aliases.includes(name) && this.name !== name)
                return;
        }
        else if (!this._aliases.includes(argv.name) && this.name !== argv.name)
            return;
        Object.assign(argv, this.parse(argv, argv.args || [], argv.options || {}));
        const { args, error } = argv;
        if (error)
            throw new Error(error);
        for (const validator of this._checkers) {
            const result = await validator.call(this, argv, ...args);
            if (result)
                return result;
        }
        for (const action of this._actions) {
            const result = await action.call(this, argv, ...args);
            if (result)
                return result;
        }
    }
    subcommand(def, ...args) {
        const desc = typeof args[0] === 'string' ? args.shift() : '';
        const config = args[0] || {};
        const command = defineCommand(def, desc, config);
        command.parent = this;
        this.children.push(command);
        return command;
    }
    stringifyArg(value) {
        value = '' + value;
        return value.includes(' ') ? `"${value}"` : value;
    }
    stringify(args, options) {
        let output = this.name;
        for (const key in options) {
            const value = options[key];
            if (value === true) {
                output += ` --${key}`;
            }
            else if (value === false) {
                output += ` --no-${key}`;
            }
            else {
                output += ` --${key} ${this.stringifyArg(value)}`;
            }
        }
        for (const arg of args) {
            output += ' ' + this.stringifyArg(arg);
        }
        return output;
    }
}
exports.Command = Command;
function defineCommand(def, ...args) {
    const desc = typeof args[0] === 'string' ? args.shift() : '';
    const config = args[0];
    const name = def.split(' ', 1)[0];
    const decl = def.slice(name.length);
    const command = new Command(name, decl, desc);
    if (config) {
        Object.assign(command.config || {}, config);
    }
    return command;
}
exports.defineCommand = defineCommand;
