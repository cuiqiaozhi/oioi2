"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Argv = void 0;
const leftQuotes = `"'“‘`;
const rightQuotes = `"'”’`;
var Argv;
(function (Argv) {
    const bracs = {};
    function interpolate(initiator, terminator, parse) {
        bracs[initiator] = { terminator, parse };
    }
    Argv.interpolate = interpolate;
    interpolate('$(', ')');
    function escapeRegExp(source) {
        return source
            .replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
            .replace(/-/g, '\\x2d');
    }
    Argv.escapeRegExp = escapeRegExp;
    class Tokenizer {
        constructor() {
            this.bracs = Object.create(bracs);
        }
        interpolate(initiator, terminator, parse) {
            this.bracs[initiator] = { terminator, parse };
        }
        parseToken(source, stopReg = '$') {
            const parent = { inters: [] };
            const index = leftQuotes.indexOf(source[0]);
            const quote = rightQuotes[index];
            let content = '';
            if (quote) {
                source = source.slice(1);
                stopReg = `${quote}(?=${stopReg})|$`;
            }
            stopReg += `|${Object.keys({ ...this.bracs, ...bracs }).map(escapeRegExp).join('|')}`;
            const regExp = new RegExp(stopReg);
            while (true) {
                const capture = regExp.exec(source);
                content += source.slice(0, capture.index);
                if (capture[0] in this.bracs) {
                    source = source.slice(capture.index + capture[0].length).trimStart();
                    const { parse, terminator } = this.bracs[capture[0]];
                    const argv = parse?.(source) || this.parse(source, terminator);
                    source = argv.rest;
                    parent.inters.push({ ...argv, pos: content.length, initiator: capture[0] });
                }
                else {
                    const quoted = capture[0] === quote;
                    const rest = source.slice(capture.index + +quoted);
                    parent.rest = rest.trimStart();
                    parent.quoted = quoted;
                    parent.terminator = capture[0];
                    if (quoted) {
                        parent.terminator += rest.slice(0, -parent.rest.length);
                    }
                    else if (quote) {
                        content = leftQuotes[index] + content;
                        parent.inters.forEach(inter => inter.pos += 1);
                    }
                    parent.content = content;
                    if (quote === "'")
                        Argv.revert(parent);
                    return parent;
                }
            }
        }
        parse(source, terminator = '') {
            const tokens = [];
            let rest = source, term = '';
            const stopReg = `\\s+|[${escapeRegExp(terminator)}]|$`;
            // eslint-disable-next-line no-unmodified-loop-condition
            while (rest && !(terminator && rest.startsWith(terminator))) {
                const token = this.parseToken(rest, stopReg);
                tokens.push(token);
                rest = token.rest;
                term = token.terminator;
                delete token.rest;
            }
            if (rest.startsWith(terminator))
                rest = rest.slice(1);
            source = source.slice(0, -(rest + term).length);
            return { tokens, rest, source };
        }
        stringify(argv) {
            const output = argv.tokens.reduce((prev, token) => {
                if (token.quoted)
                    prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])];
                return prev + token.content + token.terminator;
            }, '');
            if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {
                return output.slice(0, -1);
            }
            return output;
        }
    }
    Argv.Tokenizer = Tokenizer;
    const defaultTokenizer = new Tokenizer();
    function parse(source, terminator = '') {
        return defaultTokenizer.parse(source, terminator);
    }
    Argv.parse = parse;
    function stringify(argv) {
        return defaultTokenizer.stringify(argv);
    }
    Argv.stringify = stringify;
    function revert(token) {
        while (token.inters.length) {
            const { pos, source, initiator } = token.inters.pop();
            token.content = token.content.slice(0, pos)
                + initiator + source + bracs[initiator].terminator
                + token.content.slice(pos);
        }
    }
    Argv.revert = revert;
    function resolveConfig(type) {
        return typeof type === 'string' ? builtin[type] || {} : {};
    }
    Argv.resolveConfig = resolveConfig;
    function resolveType(type) {
        if (typeof type === 'function') {
            return type;
        }
        else if (type instanceof RegExp) {
            return (source) => {
                if (type.test(source))
                    return source;
                throw new Error();
            };
        }
        else if (Array.isArray(type)) {
            return (source) => {
                if (type.includes(source))
                    return source;
                throw new Error();
            };
        }
        return builtin[type]?.transform;
    }
    const builtin = {};
    function createDomain(name, transform, options) {
        builtin[name] = { ...options, transform };
    }
    Argv.createDomain = createDomain;
    createDomain('rawtext', source => source);
    createDomain('string', source => source);
    createDomain('text', source => source, { greedy: true });
    createDomain('rawtext', source => String(source)
        .replace(/&#91;/g, '[')
        .replace(/&#93;/g, ']')
        .replace(/&#44;/g, ',')
        .replace(/&amp;/g, '&'), { greedy: true });
    createDomain('boolean', () => true);
    createDomain('number', (source) => {
        const value = +source;
        if (Number.isFinite(value))
            return value;
        throw new Error('invalid-number');
    });
    createDomain('integer', (source) => {
        const value = +source;
        if (value * 0 === 0 && Math.floor(value) === value)
            return value;
        throw new Error('invalid-integer');
    });
    createDomain('posint', (source) => {
        const value = +source;
        if (value * 0 === 0 && Math.floor(value) === value && value > 0)
            return value;
        throw new Error('invalid-posint');
    });
    createDomain('natural', (source) => {
        const value = +source;
        if (value * 0 === 0 && Math.floor(value) === value && value >= 0)
            return value;
        throw new Error('invalid-natural');
    });
    createDomain('date', (source) => {
        const timestamp = new Date(source);
        if (+timestamp)
            return timestamp;
        throw new Error('invalid-date');
    });
    const BRACKET_REGEXP = /<[^>]+>|\[[^\]]+\]/g;
    function parseDecl(source) {
        let cap;
        const result = [];
        // eslint-disable-next-line no-cond-assign
        while (cap = BRACKET_REGEXP.exec(source)) {
            let rawName = cap[0].slice(1, -1);
            let variadic = false;
            if (rawName.startsWith('...')) {
                rawName = rawName.slice(3);
                variadic = true;
            }
            const [name, rawType] = rawName.split(':');
            const type = rawType ? rawType.trim() : undefined;
            result.push({
                name,
                variadic,
                type,
                required: cap[0][0] === '<',
            });
        }
        result.stripped = source.replace(/:[\w-]+[>\]]/g, str => str.slice(-1)).trimEnd();
        return result;
    }
    Argv.parseDecl = parseDecl;
    function parseValue(source, quoted, kind, argv, decl = {}) {
        const { name, type, fallback } = decl;
        // no explicit parameter & has fallback
        const implicit = source === '' && !quoted;
        if (implicit && fallback !== undefined)
            return fallback;
        // apply domain callback
        const transform = resolveType(type);
        if (transform) {
            try {
                return transform(source);
            }
            catch (err) {
                const message = err['message'] || 'check-syntax';
                argv.error = `invalid-${kind}.(${name}):${message}(${source})`
                    .replace(/invalid-/g, '无效的')
                    .replace('argument.', '参数')
                    .replace('option.', '选项');
                return;
            }
        }
        // default behavior
        if (implicit)
            return true;
        if (quoted)
            return source;
        const n = +source;
        return n * 0 === 0 ? n : source;
    }
    Argv.parseValue = parseValue;
})(Argv = exports.Argv || (exports.Argv = {}));
