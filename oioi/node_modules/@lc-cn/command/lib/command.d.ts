import { Argv } from "./argv";
import Declaration = Argv.Declaration;
declare type Extend<O extends {}, K extends string, T> = {
    [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown);
};
export declare namespace Command {
    interface Config {
        /** hide all options by default */
        hideOptions?: boolean;
        /** hide command */
        hidden?: boolean;
        /** min authority */
        authority?: number;
        /** disallow unknown options */
        checkUnknown?: boolean;
        /** check argument count */
        checkArgCount?: boolean;
        /** show command warnings */
        showWarning?: boolean;
        /** usage identifier */
        usageName?: string;
        maxUsage?: number;
        /** min interval */
        minInterval?: number;
        /** depend on existing commands */
        patch?: boolean;
    }
    interface Shortcut {
        name?: string | RegExp;
        command?: Command;
        authority?: number;
        prefix?: boolean;
        fuzzy?: boolean;
        args?: string[];
        options?: Record<string, any>;
    }
    type Action<A extends any[] = any[], O extends {} = {}> = (argv: Argv<A, O>, ...args: A) => any | Promise<any>;
}
export declare class Command<A extends any[] = any[], O extends {} = {}> {
    name: string;
    description: string;
    declaration: string;
    config: Command.Config;
    _examples: string[];
    _aliases: string[];
    private _actions;
    private _checkers;
    _arguments: Declaration[];
    _options: Argv.OptionDeclarationMap;
    parent: Command;
    children: Command[];
    private _namedOptions;
    private _symbolicOptions;
    constructor(name: string, declaration: string, description: string);
    option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<A, Extend<O, K, string>>;
    option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<A, Extend<O, K, R>>;
    option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<A, Extend<O, K, R>>;
    option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<A, Extend<O, K, Argv.OptionType<D>>>;
    private _assignOption;
    alias(...names: string[]): this;
    example(example: string): this;
    check(callback: Command.Action<A, O>, prepend?: boolean): this;
    action(callback: Command.Action<A, O>, append?: boolean): this;
    parse(argv: Argv, args?: any[], options?: {}): Argv;
    execute(argv: string | Argv): Promise<any>;
    subcommand<D extends string>(def: D, config?: Command.Config): Command<Argv.ArgumentType<D>>;
    subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<Argv.ArgumentType<D>>;
    private stringifyArg;
    stringify(args: readonly string[], options: any): string;
}
export declare function defineCommand<D extends string>(def: D, config?: Command.Config): Command<Argv.ArgumentType<D>>;
export declare function defineCommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<Argv.ArgumentType<D>>;
export {};
