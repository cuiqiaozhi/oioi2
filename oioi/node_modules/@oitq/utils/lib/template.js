"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.t = exports.template = exports.sanitize = exports.trimSlash = exports.escapeRegExp = exports.interpolate = exports.capitalize = exports.hyphenate = exports.camelize = exports.snakeCase = exports.paramCase = exports.camelCase = void 0;
function deepen(modifyString) {
    function modifyObject(source) {
        if (typeof source !== 'object' || !source)
            return source;
        if (Array.isArray(source))
            return source.map(modifyObject);
        const result = {};
        for (const key in source) {
            result[modifyString(key)] = modifyObject(source[key]);
        }
        return result;
    }
    return function (source) {
        if (typeof source === 'string') {
            return modifyString(source);
        }
        else {
            return modifyObject(source);
        }
    };
}
exports.camelCase = deepen(source => source.replace(/[_-][a-z]/g, str => str.slice(1).toUpperCase()));
exports.paramCase = deepen(source => source.replace(/_/g, '-').replace(/(?<!^)[A-Z]/g, str => '-' + str.toLowerCase()));
exports.snakeCase = deepen(source => source.replace(/-/g, '_').replace(/(?<!^)[A-Z]/g, str => '_' + str.toLowerCase()));
exports.camelize = exports.camelCase;
exports.hyphenate = exports.paramCase;
function capitalize(source) {
    return source.charAt(0).toUpperCase() + source.slice(1);
}
exports.capitalize = capitalize;
// eslint-disable-next-line no-new-func
exports.interpolate = new Function('template', 'context', 'pattern', `
  return template.replace(pattern || /\\{\\{([\\s\\S]+?)\\}\\}/g, (_, expr) => {
    try {
      with (context) {
        const result = eval(expr)
        return result === undefined ? '' : result
      }
    } catch {
      return ''
    }
  })
`);
function escapeRegExp(source) {
    return source
        .replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
        .replace(/-/g, '\\x2d');
}
exports.escapeRegExp = escapeRegExp;
function trimSlash(source) {
    return source.replace(/\/$/, '');
}
exports.trimSlash = trimSlash;
function sanitize(source) {
    if (!source.startsWith('/'))
        source = '/' + source;
    return trimSlash(source);
}
exports.sanitize = sanitize;
function template(path, ...params) {
    if (!Array.isArray(path))
        path = [path];
    for (const item of path) {
        const source = template.get(item);
        if (typeof source === 'string') {
            return template.format(source, ...params);
        }
    }
    return path[0];
}
exports.template = template;
exports.t = template;
function deepAssign(head, base) {
    Object.entries(base).forEach(([key, value]) => {
        if (typeof value === 'object' && typeof head[key] === 'object') {
            head[key] = deepAssign(head[key], value);
        }
        else {
            head[key] = base[key];
        }
    });
    return head;
}
(function (template) {
    const store = {};
    function set(path, value) {
        var _a;
        const seg = path.split('.');
        let node = store;
        while (seg.length > 1) {
            node = node[_a = seg.shift()] || (node[_a] = {});
        }
        deepAssign(node, { [seg[0]]: value });
    }
    template.set = set;
    function get(path) {
        const seg = path.split('.');
        let node = store;
        do {
            node = node[seg.shift()];
        } while (seg.length && node);
        if (typeof node === 'string')
            return node;
    }
    template.get = get;
    function format(source, ...params) {
        if (params[0] && typeof params[0] === 'object') {
            source = (0, exports.interpolate)(source, params[0]);
        }
        let result = '';
        let cap;
        // eslint-disable-next-line no-cond-assign
        while (cap = /\{(\w+)\}/.exec(source)) {
            result += source.slice(0, cap.index) + (cap[1] in params ? params[cap[1]] : '');
            source = source.slice(cap.index + cap[0].length);
        }
        return result + source;
    }
    template.format = format;
    function quote(content) {
        return get('basic.left-quote') + content + get('basic.right-quote');
    }
    template.quote = quote;
    function brace(items) {
        if (!items.length)
            return '';
        return get('basic.left-brace') + items.join(get('basic.comma')) + get('basic.right-brace');
    }
    template.brace = brace;
})(template = exports.template || (exports.template = {}));
exports.t = template;
/* eslint-disable quote-props */
template.set('basic', {
    'left-brace': '（',
    'right-brace': '）',
    'left-quote': '“',
    'right-quote': '”',
    'comma': '，',
    'and': '和',
    'or': '或',
});
