"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = void 0;
const utils_1 = require("@oitq/utils");
class Events {
    constructor(app) {
        this.app = app;
        this._hooks = {};
    }
    getListeners(name) {
        var _a;
        if (typeof name === "symbol")
            return (_a = this.app._hooks)[name] || (_a[name] = []);
        return Object.keys(this.app._hooks)
            .filter(key => {
            return new RegExp(Events.createRegStr(name)).test(key) || new RegExp(Events.createRegStr(key)).test(name);
        })
            .map(key => this.app._hooks[key])
            .flat();
    }
    static createRegStr(name) {
        name = `^${name}$`;
        for (const word of this.metaWords) {
            name = name.replace(word, `\\${word}`);
        }
        return name.replace('*', '.*');
    }
    async parallel(...args) {
        const tasks = [];
        const session = typeof args[0] === 'object' ? args.shift() : null;
        const name = args.shift();
        const hooks = this.getListeners(name);
        for (let [context, callback] of hooks) {
            if (!context.match(session))
                continue;
            tasks.push((async () => {
                return callback.apply(session, args);
            })().catch(((error) => {
                this.app.logger('app').warn(error);
            })));
        }
        await Promise.all(tasks);
    }
    emit(...args) {
        this.parallel(...args);
    }
    async waterfall(...args) {
        const session = typeof args[0] === 'object' ? args.shift() : null;
        const name = args.shift();
        for (let [context, callback] of this.getListeners(name)) {
            if (!context.match(session))
                continue;
            args[0] = await callback.apply(session, args);
        }
        return args[0];
    }
    chain(...args) {
        return this.waterfall(...args);
    }
    async serial(...args) {
        const session = typeof args[0] === 'object' ? args.shift() : null;
        const name = args.shift();
        for (let [context, callback] of this.getListeners(name)) {
            if (!context.match(session))
                continue;
            const result = await callback.apply(session, args);
            if ((0, utils_1.isBailed)(result))
                return result;
        }
    }
    bail(...args) {
        return this.serial(...args);
    }
    on(name, listener, prepend = false) {
        var _a;
        const method = prepend ? 'unshift' : 'push';
        // handle special events
        if (name === 'connect' && this.app.status) {
            return listener(), () => false;
        }
        const hooks = (_a = this.app._hooks)[name] || (_a[name] = []);
        if (hooks.length >= this.app.options.maxListeners) {
            this.app.logger('app').warn('max listener count (%d) for event "%s" exceeded, which may be caused by a memory leak', this.app.options.maxListeners, name);
        }
        // @ts-ignore
        hooks[method]([this, listener]);
        const dispose = () => {
            return this.off(name, listener);
        };
        return dispose;
    }
    before(name, listener, append = false) {
        const seg = name.split('/');
        seg[seg.length - 1] = 'before-' + seg[seg.length - 1];
        return this.on(seg.join('/'), listener, !append);
    }
    once(name, listener, prepend = false) {
        const dispose = this.on(name, function (...args) {
            dispose();
            return listener.apply(this, args);
        }, prepend);
        return dispose;
    }
    off(name, listener) {
        // @ts-ignore
        const index = (this.app._hooks[name] || []).findIndex(([context, callback]) => context === this && callback === listener);
        if (index >= 0) {
            this.app._hooks[name].splice(index, 1);
            return true;
        }
    }
}
exports.Events = Events;
Events.metaWords = './-'.split('');
