/// <reference types="node" />
import { EventEmitter } from "events";
import { App, Bot, Dispose } from ".";
import { Awaitable } from "@oitq/utils";
import { Context } from "./context";
export declare enum PluginType {
    Builtin = "builtin",
    Official = "official",
    Community = "community",
    Custom = "custom"
}
export interface PluginDesc {
    name: string;
    type: PluginType;
    fullName?: string;
    desc?: string;
    author?: string;
    version?: string;
    isInstall?: boolean;
    binds?: number[];
}
export interface PluginConfig {
    name: string;
    config?: any;
}
export declare class Plugin extends EventEmitter {
    readonly name: string;
    readonly fullpath: string;
    readonly path: string;
    protected hooks: PluginManager.Object;
    readonly binds: Set<Bot>;
    using: readonly (keyof Context.Services)[];
    private config;
    context: Context;
    constructor(name: string, hooks: string | PluginManager.Object);
    get logger(): import("log4js").Logger;
    bindCtx(ctx: Context): void;
    protected _editBotPluginCache(bot: Bot, method: "add" | "delete"): Promise<boolean>;
    install(config?: any): Promise<void>;
    enable(bot: Bot): Promise<void>;
    disable(bot: Bot): Promise<void>;
    uninstall(): Promise<void>;
    restart(): Promise<void>;
}
export declare class PluginManager {
    app: App;
    config: PluginManager.Config;
    plugins: Map<string, Plugin>;
    private pluginsCache;
    constructor(app: App, config: PluginManager.Config);
    get logger(): import("log4js").Logger;
    init(): void;
    import(name: string): Plugin;
    install(plugin: Plugin, config?: any): void;
    checkInstall(name: string): Plugin;
    uninstall(name: string): Promise<void>;
    restart(name: string): Promise<void>;
    enable(name: string, bot: Bot): Promise<void>;
    disable(name: string, bot: Bot): Promise<void>;
    disableAll(bot: Bot): Promise<void>;
    loadAllPlugins(): PluginDesc[];
    /**
     * 恢复bot的插件服务
     * @param {Bot} bot
     */
    restore(bot: Bot): Promise<Map<string, Plugin>>;
}
export declare namespace PluginManager {
    const defaultConfig: Config;
    type Plugin = Function | Object;
    type Function<T = any> = (ctx: Context, options: T) => Awaitable<any>;
    interface Object<T = any> {
        install: Function<T>;
        using?: readonly (keyof Context.Services)[];
        name?: string;
        uninstall?(ctx: Context): Awaitable<any>;
        enable?(bot: Bot): Awaitable<any>;
        disable?(bot: Bot): Awaitable<any>;
    }
    type Option<T extends Plugin> = T extends Function<infer U> ? U : T extends Object<infer U> ? U : never;
    interface Config {
        plugin_dir?: string;
        plugins?: Record<string, any>;
    }
}
export declare namespace Plugin {
    interface State {
        context: Context;
        children: Context[];
        disposes: Dispose[];
        plugin: Plugin;
    }
}
