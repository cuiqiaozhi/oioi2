import { Bot, BotEventMap, BotList, NSession, TargetType } from "./bot";
import { App } from "./app";
import { Plugin, PluginManager } from "./plugin";
import { Argv, Command } from "@lc-cn/command";
import { Awaitable, MaybeArray } from "@oitq/utils";
import { Events } from "./event";
import { Middleware } from "./middleware";
import { Sendable } from "oicq";
declare const selectors: readonly ["user", "group", "self", "private"];
export declare type SelectorType = typeof selectors[number];
export declare type SelectorValue = boolean | MaybeArray<number>;
export declare type BaseSelection = {
    [K in SelectorType as `$${K}`]?: SelectorValue;
};
export interface Selection extends BaseSelection {
    $and?: Selection[];
    $or?: Selection[];
    $not?: Selection;
}
export declare type Filter = (session: NSession<'message'>) => boolean;
declare type EventName = keyof AppEventMap;
declare type ServiceAction = "load" | 'change' | 'destroy' | 'enable' | 'disable';
declare type ServiceListener<K extends keyof Context.Services = keyof Context.Services> = (key: K, service: Context.Services[K]) => void;
declare type OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never;
declare type ServiceEventMap = {
    [P in ServiceAction as `service.${P}`]: ServiceListener;
};
export declare type BeforeEventMap = {
    [E in EventName & string as OmitSubstring<E, 'before-'>]: AppEventMap[E];
};
export interface AppEventMap extends BotEventMap, ServiceEventMap {
    'ready'(): void;
    'dispose'(): void;
    'command/before-execute'(argv: Argv): Awaitable<void | string>;
    'before-parse'(content: string, session: NSession<'message'>): void;
    'before-attach'(session: NSession<'message'>): void;
    'attach'(session: NSession<'message'>): void;
    'bot-added'(bot: Bot): void;
    'bot-removed'(bot: Bot): void;
    'plugin-added'(plugin: Plugin): void;
    'plugin-removed'(plugin: Plugin): void;
    'before-command'(argv: Argv): Awaitable<void | string>;
    'help/command'(output: string[], command: Command, session: NSession<'message'>): void;
    'help/option'(output: string, option: Argv.OptionDeclaration, command: Command, session: NSession<'message'>): string;
}
export declare type Dispose = () => boolean;
export declare type MsgChannelId = `${number}-${TargetType}:${number}`;
export interface Context extends Context.Services {
    on<E extends keyof AppEventMap>(name: E, listener: AppEventMap[E], prepend?: boolean): Dispose;
    on<S extends string | symbol>(name: S & Exclude<S, keyof AppEventMap>, listener: (...args: any) => void, prepend?: boolean): Dispose;
    before<E extends keyof BeforeEventMap>(name: E, listener: BeforeEventMap[E], append?: boolean): Dispose;
    before<S extends string | symbol>(name: S & Exclude<S, keyof BeforeEventMap>, listener: (...args: any) => void, append?: boolean): Dispose;
    once<E extends keyof AppEventMap>(name: E, listener: AppEventMap[E], prepend?: boolean): Dispose;
    once<S extends string | symbol>(name: S & Exclude<S, keyof AppEventMap>, listener: (...args: any) => void, prepend?: boolean): Dispose;
    addEventListener<E extends keyof AppEventMap>(name: E, listener: AppEventMap[E], prepend?: boolean): Dispose;
    addEventListener<S extends string | symbol>(name: S & Exclude<S, keyof AppEventMap>, listener: (...args: any) => void, prepend?: boolean): Dispose;
    emit<E extends keyof AppEventMap>(name: E, ...args: Parameters<AppEventMap[E]>): boolean;
    emit<S extends string | symbol>(name: S & Exclude<S, keyof AppEventMap>, ...args: any[]): boolean;
}
export declare class Context extends Events {
    filter: Filter;
    app?: App;
    _plugin: Plugin;
    constructor(filter: Filter, app?: App, _plugin?: Plugin);
    logger(name: string): import("log4js").Logger;
    get state(): Plugin.State;
    intersect(arg: Filter | Context): Context;
    private _property;
    exclude(arg: Filter | Context): Context;
    any(): Context;
    never(): Context;
    union(arg: Filter | Context): Context;
    user(...values: number[]): Context;
    group(...values: number[]): Context;
    private(...values: number[]): Context;
    select(options: Selection): Context;
    match(session?: NSession<'message'>): boolean;
    broadcast(msgChannelIds: MsgChannelId | MsgChannelId[], msg: Sendable): Promise<void>;
    using<T extends PluginManager.Plugin>(using: readonly (keyof Context.Services)[], plugin: T, config?: PluginManager.Option<T>): this;
    dispose(plugin?: Plugin): void;
    middleware(middleware: Middleware): Dispose;
    plugin(name: string, config?: any): this;
    plugin<T extends PluginManager.Plugin>(plugin: T, config?: PluginManager.Option<T>): this;
    command<D extends string>(def: D, config?: Command.Config): Command<Argv.ArgumentType<D>>;
    command<D extends string>(def: D, desc: string, config?: Command.Config): Command<Argv.ArgumentType<D>>;
}
export declare namespace Context {
    interface Services {
        pluginManager: PluginManager;
        bots: BotList;
    }
    function service<K extends keyof Services>(key: K): void;
}
export {};
