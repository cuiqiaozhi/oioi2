"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginManager = exports.Plugin = exports.PluginType = void 0;
const events_1 = require("events");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const utils_1 = require("@oitq/utils");
class PluginError extends Error {
    constructor() {
        super(...arguments);
        this.name = "PluginError";
    }
}
var PluginType;
(function (PluginType) {
    PluginType["Builtin"] = "builtin";
    PluginType["Official"] = "official";
    PluginType["Community"] = "community";
    PluginType["Custom"] = "custom";
})(PluginType = exports.PluginType || (exports.PluginType = {}));
class Plugin extends events_1.EventEmitter {
    constructor(name, hooks) {
        super();
        this.name = name;
        this.binds = new Set();
        this.using = [];
        if (typeof hooks === 'string') {
            this.fullpath = require.resolve(hooks);
            this.using = require(hooks).using || [];
            this.path = hooks;
        }
        else {
            if (hooks.using)
                this.using = hooks.using;
            this.hooks = hooks;
        }
    }
    get logger() {
        return this.context.logger(`[plugin:${this.name}]`);
    }
    bindCtx(ctx) {
        this.context = ctx;
    }
    async _editBotPluginCache(bot, method) {
        const dir = path.join(bot.dir, "plugin");
        (0, utils_1.createIfNotExist)(dir, []);
        let set;
        try {
            const arr = (0, utils_1.readConfig)(dir);
            set = new Set(arr);
        }
        catch {
            set = new Set;
        }
        set[method](this.name);
        return (0, utils_1.writeConfig)(dir, Array.from(set));
    }
    async install(config) {
        if (config)
            this.config = config;
        else
            config = this.config;
        if (this.path) {
            require(this.path);
            const mod = require.cache[this.fullpath];
            this.hooks = mod.exports;
        }
        if (typeof this.hooks.install !== "function") {
            throw new PluginError(`插件(${this.name})未导出install方法，无法安装。`);
        }
        try {
            const res = this.hooks.install(this.context, config);
            if (res instanceof Promise)
                await res;
            this.logger.info(`已成功安装`);
        }
        catch (e) {
            throw new PluginError(`安装插件(${this.name})时遇到错误。\n错误信息：` + e.message);
        }
    }
    async enable(bot) {
        if (this.binds.has(bot)) {
            throw new PluginError(`这个机器人实例已经启用了插件(${this.name})`);
        }
        if (this.path) {
            require(this.path);
            const mod = require.cache[this.fullpath];
            this.hooks = mod.exports;
        }
        if (typeof this.hooks.enable !== "function") {
            this.logger.warn(`插件未导出enable方法`);
        }
        else {
            try {
                const res = this.hooks.enable(bot);
                if (res instanceof Promise)
                    await res;
                await this._editBotPluginCache(bot, "add");
            }
            catch (e) {
                throw new PluginError(`启用插件(${this.name})时遇到错误。\n错误信息：` + e.message);
            }
        }
        this.binds.add(bot);
        this.logger.info(`成功对机器人${bot.uin}启用`);
    }
    async disable(bot) {
        if (!this.binds.has(bot)) {
            throw new PluginError(`这个机器人实例尚未启用插件(${this.name})`);
        }
        if (this.path) {
            require(this.path);
            const mod = require.cache[this.fullpath];
            this.hooks = mod.exports;
        }
        if (typeof this.hooks.disable !== "function") {
            this.logger.warn(`未导出disable方法，无法禁用。`);
        }
        else {
            try {
                const res = this.hooks.disable(bot);
                if (res instanceof Promise)
                    await res;
                await this._editBotPluginCache(bot, "delete");
            }
            catch (e) {
                throw new PluginError(`禁用插件(${this.name})时遇到错误。\n错误信息：` + e.message);
            }
        }
        this.binds.delete(bot);
        this.logger.info(`成功对机器人${bot.uin}禁用`);
    }
    async uninstall() {
        this.logger.info(`正在卸载...`);
        this.context.dispose(this);
    }
    async restart() {
        this.logger.info(`正在重新安装...`);
        try {
            await this.uninstall();
            await this.install(this.config);
            for (let bot of this.binds) {
                await this.enable(bot);
            }
        }
        catch (e) {
            throw new PluginError(`重启插件(${this.name})时遇到错误。\n错误信息：` + e.message);
        }
    }
}
exports.Plugin = Plugin;
class PluginManager {
    constructor(app, config) {
        this.app = app;
        this.plugins = new Map();
        this.pluginsCache = new Map();
        this.config = (0, utils_1.merge)(config, PluginManager.defaultConfig);
    }
    get logger() {
        return this.app.logger('pluginManager');
    }
    init() {
        const builtinPath = path.join(__dirname, 'plugins');
        const builtins = fs.readdirSync(builtinPath, { withFileTypes: true });
        // 安装内置插件
        for (let file of builtins) {
            let fileName;
            if (file.isDirectory()) {
                fileName = file.name;
            }
            else if (file.isFile() && ((file.name.endsWith('.ts') && !file.name.endsWith('d.ts')) || file.name.endsWith('.js'))) {
                fileName = file.name.replace(/\.ts|\.js/, '');
            }
            if (fileName) {
                const plugin = new Plugin(fileName, `${builtinPath}/${fileName}`);
                plugin.bindCtx(this.app);
                this.install(plugin);
                this.app.on('bot.add', (bot) => {
                    this.checkInstall(fileName).enable(bot);
                });
            }
        }
        for (const [name, conf] of Object.entries(this.config.plugins)) {
            try {
                this.app.plugin(name, conf);
            }
            catch (e) {
                if (e instanceof PluginError) {
                    this.logger.warn(e.message);
                }
                else {
                    throw e;
                }
            }
        }
    }
    import(name) {
        if (this.plugins.has(name))
            return this.plugins.get(name);
        let resolved = "";
        const modulePath = path.join(process.cwd(), "node_modules");
        const orgPath = path.resolve(modulePath, '@oitq');
        if (fs.existsSync(this.config.plugin_dir)) {
            try {
                require.resolve(`${this.config.plugin_dir}/${name}`);
                resolved = `${this.config.plugin_dir}/${name}`;
            }
            catch {
            }
        }
        if (!resolved) { //尝试在全局包里面查找官方插件
            try {
                require.resolve('@oitq/plugin-' + name);
                resolved = '@oitq/plugin-' + name;
            }
            catch { }
        }
        if (!resolved) { //尝试在全局包里面查找社区插件
            try {
                require.resolve('oitq-plugin-' + name);
                resolved = 'oitq-plugin-' + name;
            }
            catch { }
        }
        if (!resolved && fs.existsSync(orgPath)) { //尝试在当前目录的依赖查找官方插件
            try {
                require.resolve(modulePath + '/' + '@oitq/plugin-' + name);
                resolved = modulePath + '/' + '@oitq/plugin-' + name;
            }
            catch { }
        }
        if (!resolved && fs.existsSync(modulePath)) { //尝试在当前目录的依赖查找社区插件
            try {
                require.resolve(modulePath + '/' + 'oitq-plugin-' + name);
                resolved = modulePath + '/' + 'oitq-plugin-' + name;
            }
            catch { }
        }
        if (!resolved)
            throw new PluginError(`插件名错误，无法找到插件(${name})`);
        return new Plugin(name, resolved);
    }
    install(plugin, config) {
        plugin.install(config);
        this.plugins.set(plugin.name, plugin);
    }
    checkInstall(name) {
        if (!this.plugins.has(name)) {
            throw new PluginError(`尚未安装插件(${name})`);
        }
        return this.plugins.get(name);
    }
    async uninstall(name) {
        await this.checkInstall(name).uninstall();
        this.plugins.delete(name);
    }
    restart(name) {
        return this.checkInstall(name).restart();
    }
    enable(name, bot) {
        return this.checkInstall(name).enable(bot);
    }
    disable(name, bot) {
        return this.checkInstall(name).disable(bot);
    }
    async disableAll(bot) {
        for (let [_, plugin] of this.plugins) {
            try {
                await plugin.disable(bot);
            }
            catch {
            }
        }
    }
    loadAllPlugins() {
        const custom_plugins = [], module_plugins = [], builtin_plugins = [];
        const modulePath = path.join(process.cwd(), "node_modules");
        const orgPath = path.join(modulePath, '@oitq');
        // 列出的插件不展示内置插件
        const builtinPath = path.join(__dirname, 'plugins');
        const builtinPlugins = fs.readdirSync(builtinPath, { withFileTypes: true });
        for (let file of builtinPlugins) {
            if (file.isDirectory()) {
                try {
                    require.resolve(`${builtinPath}/${file.name}`);
                    builtin_plugins.push({
                        name: file.name,
                        type: PluginType.Builtin
                    });
                }
                catch {
                }
            }
            else if (file.isFile() && ((file.name.endsWith('.ts') && !file.name.endsWith('d.ts')) || file.name.endsWith('.js'))) {
                const fileName = file.name.replace(/\.ts|\.js/, '');
                try {
                    require.resolve(`${builtinPath}/${fileName}`);
                    builtin_plugins.push({
                        name: fileName,
                        type: PluginType.Builtin
                    });
                }
                catch {
                }
            }
        }
        if (fs.existsSync(this.config.plugin_dir)) {
            const customPlugins = fs.readdirSync(this.config.plugin_dir, { withFileTypes: true });
            for (let file of customPlugins) {
                if (file.isDirectory() || file.isSymbolicLink()) {
                    try {
                        require.resolve(`${this.config.plugin_dir}/${file.name}`);
                        custom_plugins.push({
                            name: file.name,
                            type: PluginType.Custom
                        });
                    }
                    catch {
                    }
                }
            }
        }
        const modules = fs.readdirSync(modulePath, { withFileTypes: true });
        for (let file of modules) {
            if (file.isDirectory() && (file.name.startsWith("oitq-plugin-"))) {
                try {
                    require.resolve(file.name);
                    module_plugins.push({
                        name: file.name.replace('oitq-plugin-', ''),
                        type: PluginType.Community,
                        fullName: file.name
                    });
                }
                catch {
                }
            }
        }
        if (fs.existsSync(orgPath)) {
            const orgModules = fs.readdirSync(orgPath, { withFileTypes: true });
            for (let file of orgModules) {
                if (file.isDirectory() && file.name.startsWith('plugin-')) {
                    try {
                        require.resolve(`@oitq/${file.name}`);
                        module_plugins.push({
                            name: file.name.replace('plugin-', ''),
                            type: PluginType.Official,
                            fullName: `@oitq/${file.name}`
                        });
                    }
                    catch {
                    }
                }
            }
        }
        const plugins = [...this.plugins.values()].map(plugin => {
            return {
                name: plugin.name,
                type: PluginType.Custom
            };
        }).filter(plugin => {
            return !custom_plugins.map(desc => desc.name).includes(plugin.name) &&
                !module_plugins.map(desc => desc.name).includes(plugin.name) &&
                !builtin_plugins.map(desc => desc.name).includes(plugin.name);
        });
        return builtin_plugins.concat(custom_plugins).concat(module_plugins).concat(plugins).map(pluginDesc => {
            const plugin = this.plugins.get(pluginDesc.name);
            return {
                ...pluginDesc,
                isInstall: this.plugins.has(pluginDesc.name),
                binds: plugin ? Array.from(plugin.binds).map(bot => bot.uin) : []
            };
        });
    }
    /**
     * 恢复bot的插件服务
     * @param {Bot} bot
     */
    async restore(bot) {
        (0, utils_1.createIfNotExist)(path.join(bot.dir, 'plugin'), []);
        const dir = path.join(bot.dir, "plugin");
        try {
            const arr = (0, utils_1.readConfig)(dir);
            for (let name of arr) {
                try {
                    await this.checkInstall(name).enable(bot);
                }
                catch {
                }
            }
        }
        catch {
        }
        return this.plugins;
    }
}
exports.PluginManager = PluginManager;
(function (PluginManager) {
    PluginManager.defaultConfig = {
        plugin_dir: path.join(process.cwd(), 'plugins'),
        plugins: {}
    };
})(PluginManager = exports.PluginManager || (exports.PluginManager = {}));
