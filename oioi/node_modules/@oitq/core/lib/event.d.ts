import { App } from "./app";
import { Context } from "./context";
export declare type EventName = string | symbol;
export declare class Events {
    app?: App;
    _hooks: Record<keyof any, [App | Context, (...args: any[]) => any][]>;
    private static metaWords;
    constructor(app?: App);
    private getListeners;
    private static createRegStr;
    parallel<K extends EventName>(name: K, ...args: any[]): Promise<void>;
    parallel<K extends EventName>(target: any, name: K, ...args: any[]): Promise<void>;
    emit<K extends EventName>(name: K, ...args: any[]): void;
    emit<K extends EventName>(target: any, name: K, ...args: any[]): void;
    waterfall<K extends EventName>(name: K, ...args: any[]): Promise<any>;
    waterfall<K extends EventName>(target: any, name: K, ...args: any[]): Promise<any>;
    chain<K extends EventName>(name: K, ...args: any[]): any;
    chain<K extends EventName>(target: any, name: K, ...args: any[]): any;
    serial<K extends EventName>(name: K, ...args: any[]): Promise<any>;
    serial<K extends EventName>(target: any, name: K, ...args: any[]): Promise<any>;
    bail<K extends EventName>(name: K, ...args: any[]): any;
    bail<K extends EventName>(target: any, name: K, ...args: any[]): any;
    on<K extends EventName>(name: K, listener: (...args: any[]) => void, prepend?: boolean): () => boolean;
    before<K extends string>(name: K, listener: (...args: any) => void, append?: boolean): () => boolean;
    once(name: EventName, listener: (...args: any[]) => void, prepend?: boolean): () => boolean;
    off<K extends EventName>(name: K, listener: (...args: any[]) => void): boolean;
}
