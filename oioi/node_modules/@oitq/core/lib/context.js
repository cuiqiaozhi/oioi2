"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const plugin_1 = require("./plugin");
const command_1 = require("@lc-cn/command");
const log4js_1 = require("log4js");
const utils_1 = require("@oitq/utils");
const event_1 = require("./event");
const selectors = ['user', 'group', 'self', 'private'];
class Context extends event_1.Events {
    constructor(filter, app, _plugin = null) {
        super();
        this.filter = filter;
        this.app = app;
        this._plugin = _plugin;
    }
    logger(name) {
        const logger = (0, log4js_1.getLogger)(name);
        logger.level = process.env.OITQ_LOG_LEVEL || this.app.options.logLevel || 'off';
        return logger;
    }
    get state() {
        return this.app.disposeState.get(this._plugin);
    }
    on(name, listener, prepend) {
        const dispose = super.on(name, listener, prepend);
        this.state.disposes.push(dispose);
        return dispose;
    }
    intersect(arg) {
        const filter = typeof arg === 'function' ? arg : arg.filter;
        return new Context(s => this.filter(s) && filter(s), this.app);
    }
    _property(key, ...values) {
        return this.intersect((session) => {
            return values.length ? values.includes(session[key]) : !!session[key];
        });
    }
    exclude(arg) {
        const filter = typeof arg === 'function' ? arg : arg.filter;
        return new Context(s => this.filter(s) && !filter(s), this.app);
    }
    any() {
        return new Context(() => true, this.app);
    }
    never() {
        return new Context(() => false, this.app);
    }
    union(arg) {
        const filter = typeof arg === 'function' ? arg : arg.filter;
        return new Context(s => this.filter(s) || filter(s), this.app);
    }
    user(...values) {
        return this._property('user_id', ...values);
    }
    group(...values) {
        return this._property('group_id', ...values);
    }
    private(...values) {
        return this.exclude(this._property('group_id'))._property('user_id', ...values);
    }
    select(options) {
        let ctx = this;
        // basic selectors
        for (const type of selectors) {
            const value = options[`$${type}`];
            if (value === true) {
                ctx = ctx[type]();
            }
            else if (value === false) {
                ctx = ctx.exclude(ctx[type]());
            }
            else if (value !== undefined) {
                // we turn everything into string
                ctx = ctx[type](...(0, utils_1.makeArray)(value));
            }
        }
        // intersect
        if (options.$and) {
            for (const selection of options.$and) {
                ctx = ctx.intersect(this.select(selection));
            }
        }
        // union
        if (options.$or) {
            let ctx2 = this.app;
            for (const selection of options.$or) {
                ctx2 = ctx2.union(this.select(selection));
            }
            ctx = ctx.intersect(ctx2);
        }
        // exclude
        if (options.$not) {
            ctx = ctx.exclude(this.select(options.$not));
        }
        return ctx;
    }
    match(session) {
        return !session || this.filter(session);
    }
    async broadcast(msgChannelIds, msg) {
        msgChannelIds = [].concat(msgChannelIds);
        for (const msgChannelId of msgChannelIds) {
            const [_, uin, target_type, target_id] = /^(\d+)-(\S+):(\d+)$/.exec(msgChannelId);
            await this.app.bots.get(Number(uin)).sendMsg(`${target_type}:${target_id}`, msg);
        }
    }
    using(using, plugin, config) {
        if (typeof plugin === 'function') {
            plugin = { install: plugin, name: plugin.name };
        }
        return this.plugin({ using, ...plugin }, config);
    }
    dispose(plugin = this._plugin) {
        const state = this.app.disposeState.get(plugin);
        for (const ctx of state.children) {
            ctx.dispose();
        }
        for (const dispose of state.disposes) {
            dispose();
        }
        state.disposes = [];
    }
    middleware(middleware) {
        const disposeArr = [];
        for (const bot of this.bots) {
            disposeArr.push(bot.middleware(middleware));
        }
        this.on('bot.add', (bot) => {
            disposeArr.push(bot.middleware(middleware));
        });
        const dispose = () => {
            disposeArr.forEach(dispose => dispose());
            return true;
        };
        return dispose;
    }
    plugin(entry, config) {
        let plugin;
        if (typeof entry === 'string')
            plugin = this.pluginManager.import(entry);
        else if (entry instanceof plugin_1.Plugin)
            plugin = entry;
        else {
            if (typeof entry === 'function')
                entry = { install: entry, name: config?.name || entry?.name || Math.random().toString() };
            plugin = new plugin_1.Plugin(entry?.name || Math.random().toString(), entry);
        }
        const context = new Context(this.filter, this.app, plugin);
        plugin.bindCtx(context);
        this.app.disposeState.set(plugin, {
            plugin,
            context,
            children: [],
            disposes: []
        });
        this.state.children.push(context);
        const using = plugin['using'] || [];
        if (using.length) {
            this.on('service.load', async (name) => {
                if (!using.includes(name))
                    return;
                callback();
            });
        }
        const callback = () => {
            if (using.some(name => !this[name]))
                return;
            this.app.pluginManager.install(plugin, config);
        };
        callback();
        return this;
    }
    command(def, ...args) {
        const desc = typeof args[0] === 'string' ? args.shift() : '';
        const config = args[0];
        const path = def.split(' ', 1)[0];
        const decl = def.slice(path.length);
        const segments = path.split(/(?=[./])/g);
        let parent, root;
        segments.forEach((segment, index) => {
            const code = segment.charCodeAt(0);
            const name = code === 46 ? parent.name + segment : code === 47 ? segment.slice(1) : segment;
            let command = this.app._commands.get(name);
            if (command) {
                if (parent) {
                    if (command === parent) {
                        throw new Error(`cannot set a command (${command.name}) as its own subcommand`);
                    }
                    if (command.parent) {
                        if (command.parent !== parent) {
                            throw new Error(`cannot create subcommand ${path}: ${command.parent.name}/${command.name} alconnect exists`);
                        }
                    }
                    else {
                        command.parent = parent;
                        parent.children.push(command);
                    }
                }
                return parent = command;
            }
            command = new command_1.Command(name, decl, index === segments.length - 1 ? desc : '');
            command.config = config || {};
            command.context = this;
            this.app._commands.set(name, command);
            this.app._commandList.push(command);
            this.state.disposes.push(() => (0, utils_1.remove)(this.app._commandList, command), () => {
                this.app._commands.delete(name);
                return true;
            });
            this.emit('command.add', command);
            if (!root)
                root = command;
            if (parent) {
                command.parent = parent;
                command.config.authority = parent.config.authority;
                parent.children.push(command);
            }
            parent = command;
        });
        if (desc)
            parent.description = desc;
        Object.assign(parent.config || (parent.config = {}), config);
        if (!config?.patch) {
            return parent;
        }
        return Object.create(parent);
    }
}
exports.Context = Context;
(function (Context) {
    function service(key) {
        if (Object.prototype.hasOwnProperty.call(Context.prototype, key))
            return;
        const privateKey = Symbol(key);
        Object.defineProperty(Context.prototype, key, {
            get() {
                const value = this.app[privateKey];
                if (!value)
                    return;
                return value;
            },
            set(value) {
                const oldValue = this.app[privateKey];
                if (oldValue === value)
                    return;
                this.app[privateKey] = value;
                const action = value ? oldValue ? 'change' : 'load' : 'destroy';
                this.emit(`service.${action}`, key, value);
                this.logger('service').debug(key, action);
            },
        });
    }
    Context.service = service;
})(Context = exports.Context || (exports.Context = {}));
Context.service('bots');
Context.service('pluginManager');
