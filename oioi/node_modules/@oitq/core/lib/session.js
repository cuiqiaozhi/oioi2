"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const _1 = require(".");
const utils_1 = require("@oitq/utils");
const command_1 = require("@lc-cn/command");
class Session {
    constructor(app, bot, data) {
        this.app = app;
        this.bot = bot;
        Object.assign(this, data);
        if (data.message) {
            this.cqCode = (0, utils_1.toCqcode)(data);
        }
        if (data.reply) {
            this.reply = (content, source) => {
                const msgList = [].concat(content).map(msg => typeof msg === 'string' ? (0, utils_1.fromCqcode)(msg) : msg);
                return data.reply(msgList.flat(1), source);
            };
        }
    }
    middleware(middleware) {
        const channelId = this.getChannelId();
        return this.bot.middleware(session => {
            if (session.getChannelId() !== channelId)
                return;
            middleware(session);
            return true;
        }, true);
    }
    promptReal(prev, answer, options) {
        if (typeof options.type === 'function')
            options.type = options.type(prev, answer, options);
        if (!options.type)
            return;
        if (['select', 'multipleSelect'].includes(options.type) && !options.choices)
            throw new Error('choices is required');
        return new Promise(resolve => {
            this.reply(_1.Prompt.formatOutput(prev, answer, options));
            const dispose = this.middleware((session) => {
                const cb = () => {
                    let result = _1.Prompt.formatValue(prev, answer, options, session.message);
                    dispose();
                    resolve(result);
                    clearTimeout(timer);
                };
                if (!options.validate) {
                    cb();
                }
                else {
                    if (typeof options.validate !== "function") {
                        options.validate = (str) => options.validate.test(str);
                    }
                    try {
                        let result = options.validate(session.cqCode);
                        if (result && typeof result === "boolean")
                            cb();
                        else
                            this.reply(options.errorMsg);
                    }
                    catch (e) {
                        this.reply(e.message);
                    }
                }
            });
            const timer = setTimeout(() => {
                dispose();
                resolve();
            }, options.timeout || this.app.options.delay.prompt);
        });
    }
    async prompt(options) {
        options = [].concat(options);
        let answer = {};
        let prev = undefined;
        try {
            if (options.length === 0)
                return;
            for (const option of options) {
                if (typeof option.type === 'function')
                    option.type = option.type(prev, answer, option);
                if (!option.type)
                    continue;
                if (!option.name)
                    throw new Error('name is required');
                prev = await this.promptReal(prev, answer, option);
                answer[option.name] = prev;
            }
        }
        catch (e) {
            this.reply(e.message);
            return;
        }
        return answer;
    }
    async prefixInters(argv) {
        if (!argv.tokens)
            return;
        for (const token of argv.tokens) {
            let { content } = token;
            for (const inter of token.inters) {
                const contentArr = content.split('');
                contentArr.splice(inter.pos, 0, inter.initiator, inter.source, inter.initiator ? ')' : '');
                content = contentArr.join('');
            }
            token.content = content;
        }
    }
    async execute(content = this.cqCode, autoReply = true) {
        for (const [, command] of this.app._commands) {
            const argv = command_1.Argv.parse(content);
            argv.bot = this.bot;
            argv.session = this;
            await this.prefixInters(argv);
            if (!command.match(this))
                continue;
            let result;
            try {
                result = await command.execute(argv);
                if (autoReply && typeof result === 'string')
                    return await this.reply(result);
            }
            catch { }
            if (result)
                return result;
        }
    }
    getChannelId() {
        return [
            this.post_type,
            this.message_type,
            this.notice_type,
            this.request_type,
            this.sub_type,
        ].filter(Boolean).join('.') + ':' + [
            this.group_id,
            this.discuss_id,
            this.user_id
        ].filter(Boolean).join('.');
    }
    resolveValue(source) {
        return typeof source === 'function' ? Reflect.apply(source, null, [this]) : source;
    }
    text(path, params = {}) {
        return (0, utils_1.template)(path, params);
    }
    toJSON() {
        return Object.fromEntries(Object.entries(this).filter(([key, value]) => {
            return !['app', 'bot'].includes(key) && !key.startsWith('_');
        }));
    }
}
exports.Session = Session;
