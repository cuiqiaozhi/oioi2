"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OneBot = void 0;
const fs = __importStar(require("fs"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = require("url");
const ws_1 = require("ws");
const rfdc_1 = __importDefault(require("rfdc"));
const filter_1 = require("./filter");
const static_1 = require("./static");
const config_1 = require("./config");
const utils_1 = require("@oitq/utils");
const clone = (0, rfdc_1.default)();
class NotFoundError extends Error {
}
class OneBot {
    constructor(app, bot, config = config_1.defaultOneBotConfig) {
        this.app = app;
        this.bot = bot;
        this.config = config;
        this._queue = [];
        this.wsr = new Set(); //反向ws连接
        this.queue_running = false;
        this.timestamp = Date.now();
    }
    /**
     * 上报事件
     */
    _dispatch(unserialized) {
        const serialized = JSON.stringify(unserialized);
        for (const ws of this.wsr) {
            ws.send(serialized);
        }
        if (this.wss) {
            for (const ws of this.wss.clients) {
                ws.send(serialized, (err) => {
                    if (err)
                        this.app.logger('OneBot').error(`OneBot - 正向WS(${ws.url})上报事件失败: ` + err.message);
                    else
                        this.app.logger('OneBot').debug(`OneBot - 正向WS(${ws.url})上报事件成功: ` + serialized);
                });
            }
        }
        if (!(this.config.post_url?.length > 0))
            return;
        const options = {
            method: "POST",
            timeout: this.config.post_timeout * 1000,
            headers: {
                "Content-Type": "application/json",
                "Content-Length": Buffer.byteLength(serialized),
                "X-Self-ID": String(this.bot.uin),
                "User-Agent": "OneBot",
            },
        };
        if (this.config.secret) {
            //@ts-ignore
            options.headers["X-Signature"] = "sha1=" + crypto.createHmac("sha1", String(this.config.secret)).update(serialized).digest("hex");
        }
        for (const url of this.config.post_url) {
            const protocol = url.startsWith("https") ? https_1.default : http_1.default;
            try {
                protocol.request(url, options, (res) => {
                    if (res.statusCode !== 200)
                        return this.app.logger('OneBot').warn(`OneBot - POST(${url})上报事件收到非200响应：` + res.statusCode);
                    let data = "";
                    res.setEncoding("utf-8");
                    res.on("data", (chunk) => data += chunk);
                    res.on("end", () => {
                        this.app.logger('OneBot').debug(`OneBot - 收到HTTP响应 ${res.statusCode} ：` + data);
                        if (!data)
                            return;
                        try {
                            this._quickOperate(unserialized, JSON.parse(data));
                        }
                        catch (e) {
                            this.app.logger('OneBot').error(`OneBot - 快速操作遇到错误：` + e.message);
                        }
                    });
                }).on("error", (err) => {
                    this.app.logger('OneBot').error(`OneBot - POST(${url})上报事件失败：` + err.message);
                }).end(serialized, () => {
                    this.app.logger('OneBot').debug(`OneBot - POST(${url})上报事件成功: ` + serialized);
                });
            }
            catch (e) {
                this.app.logger('OneBot').error(`OneBot - POST(${url})上报失败：` + e.message);
            }
        }
    }
    /**
     * 上报业务事件
     */
    dispatch(data) {
        let unserialized = data;
        switch (data.post_type) {
            case "message":
                unserialized = clone(unserialized);
                if (this.config.post_message_format === "string") {
                    unserialized.message = (0, utils_1.toCqcode)(data);
                }
                else {
                    unserialized.message = (0, utils_1.toSegment)(data.message);
                }
                break;
            case "notice":
                if (this.config.use_cqhttp_notice) {
                    unserialized = clone(unserialized);
                    (0, static_1.transNotice)(unserialized);
                }
                break;
        }
        if (!(0, filter_1.assert)(this.filter, unserialized))
            return;
        this._dispatch(unserialized);
    }
    /**
     * 处理http请求
     */
    async _httpRequestHandler(ctx) {
        if (ctx.method === 'OPTIONS' && this.config.enable_cors) {
            return ctx.writeHead(200, {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type, authorization'
            }).end();
        }
        const url = new url_1.URL(ctx.url, `http://127.0.0.1`);
        if (this.config.access_token) {
            if (ctx.headers["authorization"]) {
                if (!ctx.headers["authorization"].includes(this.config.access_token))
                    return ctx.writeHead(403).end();
            }
            else {
                const access_token = url.searchParams.get("access_token");
                if (!access_token)
                    return ctx.writeHead(401).end();
                else if (!access_token.includes(this.config.access_token))
                    return ctx.writeHead(403).end();
            }
        }
        ctx.res.setHeader("Content-Type", "application/json; charset=utf-8");
        if (this.config.enable_cors)
            ctx.res.setHeader("Access-Control-Allow-Origin", "*");
        const action = url.pathname.replace(`/${this.bot.uin}`, '').slice(1);
        if (ctx.method === "GET") {
            try {
                const ret = await this.apply({ action, params: ctx.query });
                ctx.res.end(ret);
            }
            catch (e) {
                ctx.res.writeHead(500).end(e.message);
            }
        }
        else if (ctx.method === "POST") {
            try {
                const params = { ...ctx.query, ...ctx.request.body };
                ctx.res.end(await this.apply({ action, params }));
            }
            catch (e) {
                ctx.res.writeHead(500).end(e.message);
            }
        }
        else {
            ctx.res.writeHead(405).end();
        }
    }
    /**
     * 处理ws消息
     */
    _webSocketHandler(ws) {
        ws.on("message", async (msg) => {
            this.app.logger('OneBot').debug("OneBot - 收到ws消息：" + msg);
            var data;
            try {
                data = JSON.parse(String(msg));
                let ret;
                if (data.action.startsWith(".handle_quick_operation")) {
                    const event = data.params.context, res = data.params.operation;
                    this._quickOperate(event, res);
                    ret = JSON.stringify({
                        retcode: 1,
                        status: "async",
                        data: null,
                        error: null,
                        echo: data.echo
                    });
                }
                else {
                    ret = await this.apply(data);
                }
                ws.send(ret);
            }
            catch (e) {
                let code, message;
                if (e instanceof NotFoundError) {
                    code = 1404;
                    message = "不支持的api";
                }
                else {
                    code = 1400;
                    message = "请求格式错误";
                }
                ws.send(JSON.stringify({
                    retcode: code,
                    status: "failed",
                    data: null,
                    error: {
                        code, message
                    },
                    echo: data?.echo
                }));
            }
        });
        ws.send(JSON.stringify((0, static_1.genMetaEvent)(this.bot.uin, "connect")));
        ws.send(JSON.stringify((0, static_1.genMetaEvent)(this.bot.uin, "enable")));
    }
    /**
     * 调用api
     */
    async apply(req) {
        let { action, params, echo } = req;
        let is_async = action.includes("_async");
        if (is_async)
            action = action.replace("_async", "");
        let is_queue = action.includes("_rate_limited");
        if (is_queue)
            action = action.replace("_rate_limited", "");
        if (action === "send_msg") {
            if (["private", "group", "discuss"].includes(params.message_type)) {
                action = "send_" + params.message_type + "_msg";
            }
            else if (params.user_id)
                action = "send_private_msg";
            else if (params.group_id)
                action = "send_group_msg";
            else if (params.discuss_id)
                action = "send_discuss_msg";
            else
                throw new Error('required message_type or input (user_id/group_id)');
        }
        if (action === "set_restart") {
            this.stop().then(this.start.bind(this));
            const result = {
                retcode: 1,
                status: "async",
                data: null,
                error: null
            };
            if (echo) {
                result.echo = echo;
            }
            return JSON.stringify(result);
        }
        const method = (0, static_1.toHump)(action);
        if (static_1.APIS.includes(method)) {
            const args = [];
            for (let k of static_1.ARGS[method]) {
                if (Reflect.has(params, k)) {
                    if (static_1.BOOLS.includes(k))
                        params[k] = (0, static_1.toBool)(params[k]);
                    if (k === 'message') {
                        if (typeof params[k] === 'string') {
                            params[k] = (0, utils_1.fromCqcode)(params[k]);
                        }
                        else {
                            params[k] = (0, utils_1.fromSegment)(params[k]);
                        }
                    }
                    args.push(params[k]);
                }
            }
            let ret, result;
            if (is_queue) {
                this._queue.push({ method, args });
                this._runQueue();
                result = {
                    retcode: 1,
                    status: "async",
                    data: null,
                    error: null
                };
            }
            else {
                ret = this.bot[method].apply(this.bot, args);
                if (ret instanceof Promise) {
                    if (is_async)
                        result = {
                            retcode: 1,
                            status: "async",
                            data: null,
                            error: null
                        };
                    else
                        result = {
                            retcode: 1,
                            status: "success",
                            data: await ret,
                            error: null
                        };
                }
            }
            if (result.ret instanceof Map)
                result.ret = [...result.ret.values()];
            if (echo) {
                result.echo = echo;
            }
            return JSON.stringify({ ...result, data: ret });
        }
        else {
            throw new NotFoundError();
        }
    }
    /**
     * 快速操作
     */
    _quickOperate(event, res) {
        if (event.post_type === "message") {
            if (res.reply) {
                if (event.message_type === "discuss")
                    return;
                const action = event.message_type === "private" ? "sendPrivateMsg" : "sendGroupMsg";
                const id = event.message_type === "private" ? event.user_id : event.group_id;
                this.bot[action](id, res.reply, res.auto_escape);
            }
            if (event.message_type === "group") {
                if (res.delete)
                    this.bot.deleteMsg(event.message_id);
                if (res.kick && !event.anonymous)
                    this.bot.setGroupKick(event.group_id, event.user_id, res.reject_add_request);
                if (res.ban)
                    this.bot.setGroupBan(event.group_id, event.user_id, res.ban_duration > 0 ? res.ban_duration : 1800);
            }
        }
        if (event.post_type === "request" && "approve" in res) {
            const action = event.request_type === "friend" ? "setFriendAddRequest" : "setGroupAddRequest";
            this.bot[action](event.flag, res.approve, res.reason ? res.reason : "", !!res.block);
        }
    }
    /**
     * 限速队列调用
     */
    async _runQueue() {
        if (this.queue_running)
            return;
        while (this._queue.length > 0) {
            this.queue_running = true;
            const task = this._queue.shift();
            const { method, args } = task;
            this.bot[method].apply(this.bot, args);
            await new Promise((resolve) => {
                setTimeout(resolve, this.config.rate_limit_interval);
            });
            this.queue_running = false;
        }
    }
    /**
     * 创建反向ws
     */
    _createWsr(url) {
        const timestmap = Date.now();
        const headers = {
            "X-Self-ID": String(this.bot.uin),
            "X-Client-Role": "Universal",
            "User-Agent": "OneBot",
        };
        if (this.config.access_token)
            headers.Authorization = "Bearer " + this.config.access_token;
        const ws = new ws_1.WebSocket(url, { headers });
        ws.on("error", (err) => {
            this.app.logger('OneBot').error(err.message);
        });
        ws.on("open", () => {
            this.app.logger('OneBot').info(`OneBot - 反向ws(${url})连接成功。`);
            this.wsr.add(ws);
            this._webSocketHandler(ws);
        });
        ws.on("close", (code) => {
            this.wsr.delete(ws);
            if (timestmap < this.timestamp)
                return;
            this.app.logger('OneBot').warn(`OneBot - 反向ws(${url})被关闭，关闭码${code}，将在${this.config.ws_reverse_reconnect_interval}毫秒后尝试重连。`);
            setTimeout(() => {
                if (timestmap < this.timestamp)
                    return;
                this._createWsr(url);
            }, this.config.ws_reverse_reconnect_interval);
        });
    }
    /**
     * 实例启动
     */
    async start() {
        for (const url of this.config.ws_reverse_url || [])
            this._createWsr(url);
        this._dispatch((0, static_1.genMetaEvent)(this.bot.uin, "enable"));
        if (this.config.enable_heartbeat) {
            this.heartbeat = setInterval(() => {
                this._dispatch({
                    self_id: this.bot.uin,
                    time: Math.floor(Date.now() / 1000),
                    post_type: "meta_event",
                    meta_event_type: "heartbeat",
                    interval: this.config.heartbeat_interval,
                });
            }, this.config.heartbeat_interval);
        }
        if (this.config.event_filter) {
            try {
                this.filter = JSON.parse(await fs.promises.readFile(this.config.event_filter, "utf-8"));
                this.app.logger('OneBot').info("OneBot - 事件过滤器加载成功。");
            }
            catch (e) {
                this.app.logger('OneBot').error(e.message);
                this.app.logger('OneBot').error("OneBot - 事件过滤器加载失败，将不会进行任何过滤。");
            }
        }
        if (!this.config.use_http && !this.config.use_ws)
            return;
        if (this.config.use_http) {
            this.app.on('ready', () => {
                this.app.router.all(new RegExp(`^/${this.bot.uin}/(.*)$`), this._httpRequestHandler.bind(this));
                this.app.logger('oneBot').mark(`OneBot - 开启http服务器成功，监听:http://127.0.0.1:${this.app.options.port}/${this.bot.uin}`);
            });
        }
        if (this.config.use_ws) {
            this.app.on('ready', () => {
                this.app.logger('oneBot').mark(`OneBot - 开启ws服务器成功，监听:ws://127.0.0.1:${this.app.options.port}/${this.bot.uin}`);
                this.wss = this.app.router.ws(`/${this.bot.uin}`, this.app.httpServer);
                this.wss.on("error", (err) => {
                    this.app.logger('OneBot').error(err.message);
                });
                this.wss.on("connection", (ws, req) => {
                    ws.on("error", (err) => {
                        this.app.logger('OneBot').error(err.message);
                    });
                    ws.on("close", (code, reason) => {
                        this.app.logger('OneBot').warn(`OneBot - 正向ws连接关闭，关闭码${code}，关闭理由：` + reason);
                    });
                    if (this.config.access_token) {
                        const url = new url_1.URL(req.url, "http://127.0.0.1");
                        const token = url.searchParams.get('access_token');
                        if (token)
                            req.headers["authorization"] = token;
                        if (!req.headers["authorization"] || !req.headers["authorization"].includes(this.config.access_token))
                            return ws.close(1002, "wrong access token");
                    }
                    this._webSocketHandler(ws);
                });
            });
        }
    }
    /**
     * 实例停止
     */
    async stop() {
        this.timestamp = Date.now();
        this._dispatch((0, static_1.genMetaEvent)(this.bot.uin, "disable"));
        if (this.heartbeat) {
            clearInterval(this.heartbeat);
            this.heartbeat = undefined;
        }
        for (const ws of this.wsr)
            ws.close();
        if (this.wss) {
            for (const ws of this.wss.clients)
                ws.close();
        }
    }
}
exports.OneBot = OneBot;
